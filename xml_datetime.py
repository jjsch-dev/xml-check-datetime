"""Utility to check the date and time in XML files generated by itktool.
NOTE: for generate win32 use: WINEARCH=win32 WINEPREFIX=~/win32 wine pyinstaller.exe --onefile xml_datetime.py
      for run win32: WINEARCH=win32 WINEPREFIX=~/win32 sudo wine ./xml_datetime.exe
"""
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
from datetime import datetime
import argparse
import os
import platform
import json

parser = argparse.ArgumentParser(description="xml/text date time parser")
parser.add_argument('--version', action='version', version='%(prog)s 0.1.8')
parser.add_argument("-f", "--filename", required=True, help="filename, select the XML parser, when the extension is xml.")
parser.add_argument('--card_id', dest='card_id', action='store_true', help="looks for identifiers out of sequence.")
parser.add_argument('--event_code', dest='event_code', action='store_true', help="verify that the event code is accepted.")
parser.add_argument("--gen_csv", dest='gen_csv', action='store_true', help="build a csv file, with the records plus an error field.")
parser.set_defaults(car_id=False, event_code=False, gen_csv=False)

args = parser.parse_args()

dt_last = None
records = 0
invalid = []
datetime_out_sequence = []
id_out_sequence = []
invalid_event_code = []
source_dict = {}
error_fmt_numeric = False

def parse_xml(file_name, file_extension):
    global records, invalid, error_fmt_numeric
    try:
        tree = ET.parse(file_name + file_extension)
        root = tree.getroot()

        if args.gen_csv:
            with open("csv_format.js") as stream:
                line = stream.read()
            csv_format = json.loads(line)

            if "error" in csv_format["fields"]:
                error_fmt_numeric = False if csv_format["fields"]["error"] == "string" else True

            csv_fd = csv_open(file_name)
            if csv_fd is None:
                print("error, the csv output file could not be created.")
                exit(0)

        for mark in root.findall('mark'):
            card_id = int(mark.find('access_id').text)
            date_time = mark.find('datetime')
            source = int(mark.find("source").text)
            event_code = int(mark.find("event_code").text)

            year = int(date_time.find('year').text)
            month = int(date_time.find('month').text)
            day = int(date_time.find('day').text)
            hour = int(date_time.find('hour').text)
            minute = int(date_time.find('minute').text)
            seconds = int(date_time.find('seconds').text)

            records += 1
            error = check_datetime(card_id=card_id, year=year, month=month,
                                   day=day, hour=hour, minute=minute, seconds=seconds)

            if args.card_id:
                error += check_card_id(card_id=card_id, source=source)

            if args.event_code:
                error += check_event_code(card_id=card_id, event_code=event_code)

            if args.gen_csv:
                csv_append(fd=csv_fd, card_id=card_id, year=year, month=month,
                           day=day, hour=hour, minute=minute, seconds=seconds,
                           source=source, event_code=event_code, error=error,
                           layout=csv_format)

        if args.gen_csv:
            csv_close(fd=csv_fd)
    except FileNotFoundError:
        print("error, file not found")


def check_datetime(card_id, year, month, day, hour, minute, seconds):
    global dt_last, invalid, datetime_out_sequence, records, error_fmt_numeric

    error = ""
    str_log = "mark:{} id:{} year:{} "\
              "month:{} day:{} hour:{} "\
              "minute:{} seconds: {}".format(records,
                                             card_id,
                                             year,
                                             month,
                                             day,
                                             hour,
                                             minute,
                                             seconds)
    try:
        dt = datetime(year=int(year), month=int(month),
                      day=int(day), hour=int(hour),
                      minute=int(minute), second=int(seconds))
        if dt_last is None:
            dt_last = dt
        elif dt < dt_last:
            datetime_out_sequence.append(str_log)
            error = '2' if error_fmt_numeric else "date_sequence"
        dt_last = dt
    except ValueError:
        invalid.append(str_log)
        error = '3' if error_fmt_numeric else "dt_invalid"

    return error


def check_card_id(card_id, source):
    global source_dict, records, error_fmt_numeric
    error = ''
    if source in source_dict:
        last_id = source_dict[source]

        if int(card_id) != int(last_id) + 1:
            id_out_sequence.append("mark: {} id: {} source :{}".format(records, card_id, source))
            error = ' 4' if error_fmt_numeric else ' id_sequence'

    source_dict[source] = card_id
    return error


def check_event_code(card_id, event_code):
    global invalid_event_code, error_fmt_numeric
    if event_code != 1:
        invalid_event_code.append("mark: {} id: {} event_code :{}".format(records, card_id, event_code))
        return  ' 5' if error_fmt_numeric else ' event_code'
    return ''


def parse_text(name):
    global records, invalid
    try:
        with open(name) as f:
            lines = f.readlines()  # list containing lines of file

            for line in lines:
                line = line.strip()  # remove leading/trailing white spaces
                columns = [item.strip() for item in line.split(' ')]
                dt = columns[1].split('/')
                tm = columns[2].split(':')

                records += 1
                check_datetime(card_id=columns[0],
                               year=dt[2], month=dt[1], day=dt[0],
                               hour=tm[0], minute=tm[1], seconds=tm[2])
    except FileNotFoundError:
        print("error file not found")


def csv_open(file_name):
    try:
        return open(file_name + ".csv", 'w')
    except FileNotFoundError:
        return None
    except PermissionError:
        return None


def csv_append(fd, card_id, year, month, day, hour, minute, seconds, source, event_code, error, layout):
    global error_fmt_numeric
    if len(error) == 0:
        error = "1" if error_fmt_numeric else "ok"

    fields = layout["fields"]
    for item in fields:
        if item == 'index':
            fd.write(fields[item].format(records))
        elif item == "card_id":
            fd.write(fields[item].format(card_id))
        elif item == "source":
            fd.write(fields[item].format(source))
        elif item == "event_code":
            fd.write(fields[item].format(event_code))
        elif item == "error":
            fd.write(error.lstrip(' '))
        elif item == "date":
            date = fields[item]
            for x in date:
                if x == "month":
                    fd.write(date[x].format(month))
                elif x == "year":
                    fd.write(date[x].format(year))
                elif x == "day":
                    fd.write(date[x].format(day))

                if x != list(date)[-1] and x != "sep":
                    fd.write(date["sep"])
        elif item == "time":
            date = fields[item]
            for x in date:
                if x == "hour":
                    fd.write(date[x].format(hour))
                elif x == "minute":
                    fd.write(date[x].format(minute))
                elif x == "seconds":
                    fd.write(date[x].format(seconds))

                if x != list(date)[-1] and x != "sep":
                    fd.write(date["sep"])
        if item != list(fields)[-1]:
            fd.write(layout["sep"])
    fd.write("\n")


def csv_close(fd):
    fd.close


if __name__ == '__main__':
    print("\nos: {} - arch: {} - cpu: {}\n".format(platform.system(),
                                                   platform.architecture(),
                                                   platform.processor()))

    file_name, file_extension = os.path.splitext(args.filename)

    if file_extension == ".xml":
        parse_xml(file_name, file_extension)
    elif file_extension == ".txt":
        parse_text(args.filename)
    else:
        print("error, invalid file extension: {}".format(file_extension))
        exit(0)

    if len(invalid):
        print("invalid datetime\n")
        for item in invalid:
            print(item)

    if len(datetime_out_sequence):
        print("\ndatetime out of sequence\n")
        for item in datetime_out_sequence:
            print(item)

    if len(id_out_sequence):
        print("\nid out of sequence\n")
        for item in id_out_sequence:
            print(item)

    if len(invalid_event_code):
        print("\ninvalid event code\n")
        for item in invalid_event_code:
            print(item)

    print("\nfrom {} records, {} have invalid datetime, "
          "{} dates are out of sequence, "
          "{} id out of sequence and "
          "{} invalid event code".format(records,
                                        len(invalid),
                                        len(datetime_out_sequence),
                                        len(id_out_sequence),
                                        len(invalid_event_code)))

